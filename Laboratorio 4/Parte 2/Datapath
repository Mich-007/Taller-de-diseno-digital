module datapath #(
  parameter int XLEN = 64
)(
        input  logic             clk, reset,
       
        // Control
        input  logic             PCWrite, 
        input  logic             PCWriteCond, 
        input  logic             IorD,
        input  logic             MemRead, 
        input  logic             MemWrite, 
        input  logic             IRWrite,
        input  logic [1:0]       PCSource, 
        input  logic [1:0]       MemtoReg,   //escoge el valor a escribir en registro
        input  logic [1:0]       ALUOp,
        input  logic [1:0]       ALUSrcA,
        input  logic [1:0]       ALUSrcB,   //Operacion que debe realizar la ALU
        input  logic             RegWrite,
        input  logic [2:0]       ImmSel,
       
        // ROM de instrucciones
        output logic [XLEN-1:0]  pc_addr, PC_ir,        // PC hacia instr_mem
        input  logic [31:0]      instr,             // palabra de instrucci贸n
        input  logic             instr_valid,    // 1 si la ROM entreg贸 dato
       
        // RAM de dato
        input  logic [XLEN-1:0]  rdata,
        input  logic             d_valid,
        output logic [XLEN-1:0]  d_addr,
        output logic [XLEN-1:0]  d_wdata,
        input  logic             LatchAB,
        input  logic             ALUOutEn,
         
        output logic [4:0]       rs1,
        output logic [4:0]       rs2,
        output logic [4:0]       rd,
        // Hacia control
        output logic [6:0]       opcode,
        output logic [2:0]       funct3,
        output logic [6:0]       funct7,
        output logic             Zero
);

    // ---------------- Registros ----------------
    logic [XLEN-1:0] PC, PC_next;
    logic [31:0]     instr_d;     
    logic [XLEN-1:0] read_data, A, B, ALUOut;
    
    // Campos desde IR
    assign opcode = instr_d[6:0]; 
    assign funct3 = instr_d[14:12];
    assign funct7 = instr_d[31:25];
    
    assign rs1 =    instr_d[19:15];
    assign rs2 =    instr_d[24:20];
    assign rd  =    instr_d[11:7];   
    
    // Inmediato
    logic [XLEN-1:0] Imm;
    immgen_rv64 #(.XLEN(XLEN)) 
        IMMGEN (
            .instr_d(instr_d), 
            .ImmSel(ImmSel), 
            .imm(Imm));
    
//-------------------------------------------------------------------  
//Banco de Registros
//-------------------------------------------------------------------
    logic [XLEN-1:0] read_data1, read_data2, write_data;
    
    register_file #(.DATA_WIDTH(XLEN)) RF 
        (
            .clk(clk), 
            .reset(reset), 
            .RegWrite(RegWrite),
            .rs1(rs1), 
            .rs2(rs2), 
            .rd(rd),
            .write_data(write_data), 
            .read_data1(read_data1), 
            .read_data2(read_data2)
    );

    always_ff @(posedge clk) begin
        if (IRWrite && instr_valid) 
            instr_d <= instr;
    end    
    
    
// MDR (desde RAM)
    always_ff @(posedge clk or posedge reset) begin
      if (reset)
        read_data <= '0;
      if (IorD && d_valid) 
        read_data <= rdata;
    end
   


    always_ff @(posedge clk or posedge reset) begin
      if (reset)        
        PC_ir <= '0;
      else 
      if (IRWrite) 
        PC_ir <= pc_addr;  // PC con el que se carg贸 la instrucci贸n
    end

// -------------------------------------------------------------------
// ALU datapath
// -------------------------------------------------------------------
    logic [XLEN-1:0] srcA;
    logic [XLEN-1:0] srcB; 
    logic [XLEN-1:0] ALUResult;
    logic [1:0]      Op;
       
    ALU_Control ALUCTRL 
        ( 
            .ALUOp(ALUOp), 
            .funct3(funct3), 
            .funct7(funct7), 
            .Op(Op));
            
    ALU #(.XLEN(XLEN)) 
        ALU (
            .A      (srcA), 
            .B      (srcB), 
            .Op     (Op), 
            .ALUOut (ALUResult), 
            .Zero   (Zero)
            );
        
    always_ff @(posedge clk or posedge reset) begin
      if (reset) 
        ALUOut <= '0;
      else 
      if (ALUOutEn) //Si la ALU se activa
        ALUOut <= ALUResult;
    end  
    
    always_ff @(posedge clk) begin
        if (reset) begin 
            A <= '0; 
            B <= '0; 
        end else 
        if (LatchAB) begin 
            A <= read_data1;
            B <= read_data2; 
        end
    end

// -------------------------------------------------------------------
// Multiplexores
// -------------------------------------------------------------------  
     
    always_comb begin
      // MUX de A
      unique case (ALUSrcA)  
        2'b00: srcA = PC;
        2'b01: srcA = A;       
        2'b10: srcA = PC_ir;    
        default: srcA = PC;
      endcase
      // MUX de B
      unique case (ALUSrcB) 
        2'b00: srcB = B;
        2'b01: srcB = XLEN'(4);
        2'b10: srcB = Imm;
        default: srcB = B;    
      endcase
    end

logic [XLEN-1:0] PC4;
assign PC4 = PC + XLEN'(4); 

//Mux para escoger el valor que se escribe en el registro
    always_comb begin
      unique case (MemtoReg)  
        2'b00: write_data = ALUOut;
        2'b01: write_data = read_data;
        2'b10: write_data = PC4;
        default: write_data = ALUOut;  
      endcase
    end
    
// Mux de PC
    always_comb unique case (PCSource)
      2'b00: PC_next = PC4; //R-type, I_Type                 
      2'b01: PC_next = ALUOut; //Branch               
      2'b10: PC_next = {ALUResult[XLEN-1:1],1'b0};  
      default: PC_next = PC4;
    endcase
    
// Branch y slt cond
    logic BrCondMet;
    logic shift;
    always_comb unique case (funct3)
        3'b000: BrCondMet =  (Zero); //bne
        3'b001: BrCondMet = !(Zero); //beq
        3'b010: BrCondMet = (ALUResult == 64'd1); //slt , slti
        3'b011: BrCondMet = (ALUResult == 64'd1); //sltu, sltui
        3'b100: BrCondMet = (ALUResult == 64'd1); // blt
        3'b101: BrCondMet = (ALUResult == 64'd0); // bge
      default: BrCondMet = 1'b0;
    endcase

//Valor actualizado de PC   
    wire pc_en = PCWrite | (PCWriteCond & BrCondMet);  
    always_ff @(posedge clk or posedge reset) begin
      if (reset) PC <= '0;
      else if (pc_en) PC <= PC_next;
    end
    
 // Direcciones a memorias
    assign pc_addr = PC;
    assign d_addr  = ALUOut;
    assign d_wdata = B;
endmodule
