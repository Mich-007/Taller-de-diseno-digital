// El documento se debe de llamar: tb_regfile_rv64.sv
// Testbench para banco de registros RV64I
// _________________________________________________________________________

module tb_regfile_rv64;

  // Señales internas
  logic clk;                  // Reloj de la simulación
  logic rst;                   // Señal de reset sincronizada/asíncrona según el DUT
  logic reg_write;              // Habilitador de escritura en el banco de registros
  logic [4:0] rd, rs1, rs2;      // Índices de registro destino y fuentes, esto con 5 bits para 32 regs
  logic [63:0] rd_data;         // Datos a escribir en rd, siendo los 64 bits para RV64
  logic [63:0] rs1_data, rs2_data; // Datos leídos desde rs1 y rs2, son salidas del DUT

  // Instancia del módulo bajo prueba
  regfile_rv64 dut (
    .clk(clk),                 // Conexión del reloj al DUT
    .rst(rst),                // Conexión del reset al DUT
    .reg_write(reg_write),       // Señal de write enable al DUT
    .rd(rd),                  // Puerto rd, es como el menu, al DUT
    .rs1(rs1),                  // Puerto rs1 al DUT
    .rs2(rs2),                 // Puerto rs2 al DUT
    .rd_data(rd_data),          // Datos de entrada para escribir al DUT
    .rs1_data(rs1_data),         // Salida rs1 desde el DUT, es de lectura
    .rs2_data(rs2_data)         // Salida rs2 desde el DUT, es de lectura
  );

  // Generador de reloj: periodo de 10 unidades de tiempo
  always #5 clk = ~clk;         // Invertir clk cada 5 unidades, con un periodo de 10

  // Procedimiento de prueba
  initial begin
    $display("=== INICIO DE TESTBENCH ==="); // Mensaje inicial
    clk = 0;                   // Inicializar reloj a 0
    rst = 1;                      // Activar reset inicialmente
    reg_write = 0;             // Deshabilitar escritura por defecto
    rd = 0;                     // Inicializar índice destino a x0
    rs1 = 0;                   // Inicializar índice fuente 1 a x0
    rs2 = 0;                    // Inicializar índice fuente 2 a x0
    rd_data = 64'd0;            // Inicializar datos de escritura a 0

    // Reset inicial: mantener reset activo un ciclo
    #10 rst = 0;                // De-assert reset después de 10 unidades

    // _____________________________________________________________________________
    // Caso 1: Escritura en registro x1
    // _____________________________________________________________________________
    rd = 5'd1;                  // Seleccionar registro destino x1
    rd_data = 64'h123456789ABCDEF0; // Valor de prueba
    reg_write = 1;              // Habilitar escritura para escribir en x1
    #10;                            // Esperar un ciclo para que la escritura ocurra

    // _____________________________________________________________________________
    // Caso 2: Lectura normal desde x1 y x0
    // _____________________________________________________________________________
    rs1 = 5'd1;                 // Configurar lectura de rs1 = x1 (debe devolver lo escrito)
    rs2 = 5'd0;                   // Configurar lectura de rs2 = x0 (x0 siempre 0)
    reg_write = 0;                // Deshabilitar escritura para lecturas limpias
    #1;                         // Pequeña espera para muestreo de salida
    $display("Lectura rs1 (x1): %h", rs1_data); // Mostrar valor leído en x1
    $display("Lectura rs2 (x0): %h", rs2_data); // Mostrar valor leído en x0

    // _____________________________________________________________________________
    // Caso 3: Protección de x0 (intento de escritura)
    // _____________________________________________________________________________
    rd = 5'd0;                  // Intentar escribir en x0 (registro protegido)
    rd_data = 64'hFFFFFFFFFFFFFFFF; // Valor no válido para x0 (debe ignorarse)
    reg_write = 1;              // Habilitar escritura (el DUT debe ignorar x0)
    #10;                           // Esperar un ciclo para la operación

    // Lectura desde x0 para verificar que sigue en 0 (protección)
    rs1 = 5'd0;                 // Leer x0
    reg_write = 0;                  // Deshabilitar escritura antes de leer
    #1;                         // Esperar a que las salidas se estabilicen
    $display("Lectura rs1 (x0 protegido): %h", rs1_data); // Mostrar resultado

    // _____________________________________________________________________________
    // Caso 4: Bypass de lectura (escribir y leer mismo registro en el mismo ciclo)
    // _____________________________________________________________________________
    rd = 5'd2;                  // Seleccionar registro destino x2
    rd_data = 64'h123456789ABCDEF0; // Valor de prueba para x2 (mismo patrón neutro)
    rs1 = 5'd2;                 // Leer rs1 = x2 en el mismo ciclo de escritura
    reg_write = 1;               // Habilitar escritura para comprobar bypass
    #1;                         // Lectura con bypass en el mismo ciclo
    $display("Lectura rs1 con bypass (x2): %h", rs1_data); // Mostrar lectura con bypass

    // _____________________________________________________________________________
    // Caso 5: Ejemplo adicional pedido por el usuario
    // _____________________________________________________________________________
    // Este caso añade otra escritura/lectura para ampliar las pruebas sin cambiar lo demás.
    rd = 5'd3;                   // Seleccionar registro destino x3
    rd_data = 64'h0F0F0F0F0F0F0F0F; // Valor de ejemplo adicional
    reg_write = 1;              // Habilitar escritura en x3
    #10;                           // Esperar un ciclo para que la escritura ocurra
    reg_write = 0;              // Deshabilitar escritura antes de leer
    rs1 = 5'd3;                     // Leer x3 para verificar la escritura
    #1;                         // Esperar a que la salida rs1 se actualice
    $display("Lectura rs1 (x3 - ejemplo adicional): %h", rs1_data); // Mostrar lectura x3

    // _____________________________________________________________________________
    // Prueba final: aplicar reset y comprobar que todo se borra
    // _____________________________________________________________________________
    // Preparar algunas lecturas de registros distintos antes del reset para comparar
    rs1 = 5'd1;                 // Leer x1 debe contener el valor escrito previamente
    rs2 = 5'd3;                  // Leer x3 
    #1;                         // Muestreo previo al reset
    $display("Antes de reset: rs1 (x1) = %h, rs2 (x3) = %h", rs1_data, rs2_data);

    // Aplicar reset para borrar el banco de registros
    rst = 1;                     // Activar reset
    #10;                              // Mantener reset el tiempo suficiente para que el DUT actúe

    // Desactivar reset y muestrear salidas para verificar que están en 0
    rst = 0;                 // De-assert reset
    rs1 = 5'd1;          // Leer x1 tras reset
    rs2 = 5'd3;             // Leer x3 tras reset
    #1;             // Esperar que las salidas se estabilicen
    $display("Después de reset: rs1 (x1) = %h, rs2 (x3) = %h", rs1_data, rs2_data);

    // Verificación final y fin de simulación
    #10;                     // Tiempo final antes de terminar
    $display("__________________________________________________________________________________");
    $finish;           
  end

endmodule
