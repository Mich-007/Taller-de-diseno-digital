`timescale 1ns/1ps

package fsm_pkg;
typedef enum logic [3:0] {
  S_Espera, S_RegistroActual, S_EsperaBTN, S_DATO_RX, S_DATO_TX, S_Esperar_RealTerm, S_Display
} estado_t;
endpackage

module Control #(
  parameter bit Simulacion = 0,    
  parameter int CLK_HZ       = 10_000_000, 
  parameter int DEBOUNCE_MS  = 10,   
  parameter int CNT_WIDTH = 9,
  parameter int WIDTH = 32        
)(
    input logic                     clk, reset,
    input logic                     valor_leer_listo,
    input logic                     sw0_db, sw_db_d0, sw1_db, sw_db_d1, //antirrebotes de los switches
    input logic                     reg_sel_i, wr_i,
    
    input logic                     i_fifo_tx_full,         // indicador FIFO TX llena
    input logic                     i_scdc_set_send,    // solicitar enviar 
    output logic                    i_scdc_clear_send, // clear enviar 
    input  logic                    i_scdc_set_read,   // solicitar leer 
    output logic                    i_scdc_clear_read,  // clear leer
    
    input logic  [4:0]              FIFOposicion,
    output logic [4:0]              leer_index,
    output logic                    leer_ahora,
    
    output logic [CNT_WIDTH-1:0]    o_bytes_tx,         // contadores de cuantos datos hay en la fifo
    output logic [CNT_WIDTH-1:0]    o_bytes_rx,      // Este igual de cuantos datos hay en la fifo
    input logic  [15:0]             SW, leer_data,
    input logic  [3:0]              BTN,
    
    input  logic [WIDTH-1:0]        i_reg_wr_data,   // datos de escritura(tx)
    input logic [WIDTH-1:0]         o_reg_rd_data,  // datos de lectura desde el externo(rx)
    output logic [15:0]             DisplayValor, LED,
    output logic [1:0]              op_lat,
    output logic                    PulsoMitad, PulsoFin, Displayiniciar, DisplayDone        


);
    import fsm_pkg::*;
    typedef enum logic [2:0] {R_Espera, R_SetIndex,R_EsperaDato, R_Pausa, R_Index} r_estado;
 
// -------------------------------------------------------------------
//Configuración de estados
// -------------------------------------------------------------------
    estado_t estado_actual = S_Espera, estado_siguiente;
    estado_t origen_display;
        
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin 
            estado_actual <= S_Espera;
        end else begin     
            estado_actual <= estado_siguiente;
            end
        end
        
    always_ff @(posedge clk or posedge reset) begin
        if (reset) origen_display <= S_Espera;
        else if ((estado_siguiente == S_Display) && (estado_actual != S_Display))
            origen_display <= estado_actual;
        end       

    r_estado estadoregistro;
    r_estado r_estado_q;
    
    always_ff @(posedge clk or posedge reset)
        if (reset) r_estado_q <= R_Espera;
        else       r_estado_q <= estadoregistro;   
               
    always_ff @(posedge clk or posedge reset)
        if (reset) r_estado_q <= R_Espera;
        else       r_estado_q <= estadoregistro;
 // -------------------------------------------------------------------
    // Modo Registro   
 // -------------------------------------------------------------------
    logic i_rd;
    assign i_rd = sw1_db & ~sw_db_d1;
    logic [4:0] base_index;   //  ndice del m s antiguo
    logic [5:0] k;          // cu ntos llevamos mostrados
    logic [7:0] data_registro;
    wire modo_registro = (estado_actual == S_RegistroActual) && (estado_siguiente == S_Display);
    wire displayFSM = (estado_actual != S_Display)&& (estado_siguiente == S_Display);
    wire displayregistro = (r_estado_q != R_Pausa) && (estadoregistro == R_Pausa);


     always_ff @(posedge clk or posedge reset) begin
        if (reset) origen_display <= S_Espera;
        else if ((estado_siguiente == S_Display) && (estado_actual != S_Display))
            origen_display <= estado_actual;  // guarda S_LFSRA / S_LFSRB / S_ALU
        end    

always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            estadoregistro    <= R_Espera;
            base_index  <= '0;
            k         <= '0;
            leer_index    <= '0;
            leer_ahora <= 1'b0;
        end else if (modo_registro) begin
            leer_ahora <=1'b0;
            case (estadoregistro)
                R_Espera: if(i_rd) begin
                    base_index <= FIFOposicion - o_bytes_rx[4:0];
                    k        <= 6'd0;
                    estadoregistro   <= R_SetIndex;
                end
                R_SetIndex: begin
                    leer_index <= base_index + k[4:0]; 
                    estadoregistro <= R_Index;
                end
                R_Index: begin
                    leer_ahora <=1'b1;         
                    estadoregistro <= R_EsperaDato;
                    end
                
                R_EsperaDato: if(valor_leer_listo)begin 
                    data_registro  <= leer_data;
                    estadoregistro <= R_Pausa;
                end
        
                R_Pausa: begin
                    if (PulsoFin) begin
                        if (k + 6'd1 >= o_bytes_rx) begin
                            estadoregistro <= R_Espera;
                        end else begin
                            k      <= k + 6'd1;
                            estadoregistro <= R_SetIndex;
                        end
                    end
                end
            endcase
        end else begin
            estadoregistro <= R_Espera;
            leer_ahora <= 1'b0;
        end
    end


 // -------------------------------------------------------------------  
//Contador de Display que se encarga de que cada valor se vea por 2 segundos
 // -------------------------------------------------------------------
    localparam int MAX_COUNT = Simulacion ? 20 : 20_000_000;
    localparam int unsigned HALF = MAX_COUNT/2;    
    logic VentanaActiva;
    logic[$clog2(MAX_COUNT)-1:0] DisplayContador;  
                
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            VentanaActiva <= 1'b0;
            DisplayContador <= '0;
            PulsoMitad <= 1'b0;
            PulsoFin <= 1'b0;
        end else begin
            PulsoMitad <= 1'b0;
            PulsoFin<= 1'b0;            
            if(Displayiniciar) begin
                VentanaActiva <= 1'b1;              
                DisplayContador <= MAX_COUNT -1;
            end else if (VentanaActiva) begin
            if(DisplayContador == 0) begin
                PulsoFin <= 1'b1;
                VentanaActiva <= 1'b0;
            end else begin 
            if (DisplayContador == HALF)
                PulsoMitad <= 1'b1;
                DisplayContador <= DisplayContador - 1'b1; 
            end
         end
      end     
   end

 // -------------------------------------------------------------------
    // Modo Registro   
 // -------------------------------------------------------------------
    logic start_pulse;
    
 // -------------------------------------------------------------------
//Guardar los valores de A y B en el registro
 // -------------------------------------------------------------------
    assign start_pulse = sw0_db & ~sw_db_d0;
    always_comb begin
    estado_siguiente = estado_actual;
    i_scdc_clear_send = 1'b0;
    i_scdc_clear_read = 1'b0;
    unique case (estado_actual)      
        S_Espera: 
        if (reg_sel_i == 0) begin
           estado_siguiente = wr_i ? S_EsperaBTN : S_RegistroActual;
            
        end         
        S_RegistroActual : begin
            if (!i_fifo_tx_full) begin
                VentanaActiva = 1'b1;
                estado_siguiente = S_Display;
            end
        end
        S_EsperaBTN: begin
            if(i_scdc_set_send) begin
                i_scdc_clear_send = 1'b1;
                estado_siguiente = S_DATO_TX;
                end else 
            if(i_scdc_set_read && reg_sel_i && wr_i) begin
                i_scdc_clear_read = 1'b1;
                estado_siguiente = S_DATO_RX;
            end
        end
        S_DATO_TX: begin
            estado_siguiente = S_Esperar_RealTerm;
        end
        S_DATO_RX: begin
            estado_siguiente = S_Display;
        end       
           
        S_Esperar_RealTerm:  begin           
            estado_siguiente = S_Display;   
        end 
                         
        S_Display: begin 
           
            unique case (origen_display) 
                S_RegistroActual: begin
                if(o_bytes_tx == 0 && PulsoFin) begin
                    estado_siguiente = S_Espera;
                end
                end
                S_DATO_RX: begin             
                    if(o_bytes_rx == 0 && PulsoFin) begin
                        estado_siguiente = S_Espera;  
                    end           
                end              
                default: begin
                if(PulsoFin)
                    estado_siguiente = S_Espera;
                end
            endcase
        end
        default: ;
    endcase          
    end
    

 // -------------------------------------------------------------------    
//Iniciar el Display para que muestre los valores correspondientes
 // -------------------------------------------------------------------

    always_ff @(posedge clk or posedge reset) begin 
        if (reset) begin Displayiniciar <= 1'b0; 
            DisplayValor <= 8'h00; 
        end else begin // Pulso único hacia Display 
            Displayiniciar <= 1'b0; // Valor estable en el mismo ciclo del pulso 
        if (displayregistro) begin 
            Displayiniciar <= 1'b1; 
            DisplayValor <= i_reg_wr_data; 
        end else if(displayFSM) begin 
            Displayiniciar <= 1'b1; 
            unique case (estado_actual) 
                S_RegistroActual: DisplayValor <= o_reg_rd_data; 
                S_DATO_RX: DisplayValor <= o_reg_rd_data; 
                default: DisplayValor <= 8'h00; 
            endcase 
            end 
        end 
    end
  
// -------------------------------------------------------------------
//Control de los LEDS   
// -------------------------------------------------------------------
   
    function automatic logic [15:0] onehot_idx(input int idx);
        logic [15:0] v = 16'h0000;
        v[idx] = 1'b1;
        return v;
    endfunction
    
    function automatic logic [15:0] led_from_op(input logic [1:0] op);
        unique case (op)
            2'b00: return onehot_idx(2); // AND
            2'b01: return onehot_idx(3); // OR
            2'b10: return onehot_idx(4); // SUMA
            default: return onehot_idx(5); // RESTA
        endcase
    endfunction
    
    // Para modo registro: 0?A, 1?B, 2?R, 3?A, 4?B, 5?R, ...
    function automatic logic [15:0] led_for_registro(input logic [5:0] k_val);
        case (k_val % 3)
            2'd0:  return onehot_idx(0); // A
            2'd1:  return onehot_idx(1); // B
            default:return onehot_idx(2); // R
      endcase
    endfunction
    
    
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin 
            LED <= 16'h0000; // todos apagados
        end else begin
            if (Displayiniciar) begin
          // Cuando inicia una nueva "pantalla":
                if (modo_registro) begin
            // MODO REGISTRO: LED rota 0,1,2 según k
                    LED <= led_for_registro(k);
            end else begin
            // FSM normal: A,B y ALU según operación
                unique case (origen_display)
                    S_RegistroActual: LED <= onehot_idx(0);        // LED0 = A
                    S_DATO_RX: LED <= onehot_idx(1);        // LED1 = B
                    default: LED <= 16'h0000;
                endcase
            end
            end else if (PulsoFin) begin
                 // Al terminar la ventana, apaga
                LED <= 16'h0000;
            end
        end
    end
             
endmodule
