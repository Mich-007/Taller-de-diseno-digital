`timescale 1ns/1ps
module host_buttons_to_bus #(
  parameter int CLK_HZ = 16_000_000
)(
  input  logic        clk, reset,
  input  logic [15:0] SW,
  input  logic [3:0]  BTN,         // BTN0: WR_DATOS, BTN1: RD_CONTROL, BTN2: ENVIAR, BTN3: LEER
  // Interfaz de bus hacia uart_reg_if
  output logic        reg_sel_i,   // 0=CONTROL, 1=DATOS
  output logic        wr_i,        // 1=write, 0=read
  output logic [31:0] entrada_i,
  input  logic [31:0] salida_o,    // readback del wrapper

  // Opcional: exposiciones para debug/Display
  output logic [31:0] status_o,    // última lectura de CONTROL
  output logic [7:0]  dato_leido   // último byte leído de DATOS
);

  // Debounce sencillo de botones (puedes reemplazar por tu módulo de botones)
logic b0_press, b1_press, b2_press, b3_press;

ButtonDebounce #(
  .CLK_HZ(CLK_HZ), .ACTIVE_HIGH(1), .Simulacion(0),
  .DEBOUNCE_MS_HW(10), .DEBOUNCE_MS_SIM(0)
) db0 (.clk(clk), .reset(reset), .BTN(BTN[0]), .pressed(), .press_pulse(b0_press), .release_pulse());
ButtonDebounce #(.CLK_HZ(CLK_HZ), .ACTIVE_HIGH(1), .Simulacion(0), .DEBOUNCE_MS_HW(10), .DEBOUNCE_MS_SIM(0))
  db1 (.clk(clk), .reset(reset), .BTN(BTN[1]), .pressed(), .press_pulse(b1_press), .release_pulse());
ButtonDebounce #(.CLK_HZ(CLK_HZ), .ACTIVE_HIGH(1), .Simulacion(0), .DEBOUNCE_MS_HW(10), .DEBOUNCE_MS_SIM(0))
  db2 (.clk(clk), .reset(reset), .BTN(BTN[2]), .pressed(), .press_pulse(b2_press), .release_pulse());
ButtonDebounce #(.CLK_HZ(CLK_HZ), .ACTIVE_HIGH(1), .Simulacion(0), .DEBOUNCE_MS_HW(10), .DEBOUNCE_MS_SIM(0))
  db3 (.clk(clk), .reset(reset), .BTN(BTN[3]), .pressed(), .press_pulse(b3_press), .release_pulse());

  // Defaults de bus en cada ciclo
  always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
      reg_sel_i  <= 1'b0;
      wr_i       <= 1'b0;
      entrada_i  <= 32'h0;
      status_o   <= 32'h0;
      dato_leido <= 8'h00;
    end else begin
      // Por defecto: no escribir
      wr_i      <= 1'b0;
      entrada_i <= 32'h0;

              // --- BTN0: escribir 1 byte a REG_DATOS (empuja a FIFO-TX) ---
      if (b0_press) begin
          // PUSH a TX (REG_DATOS)
          reg_sel_i <= 1'b1; wr_i <= 1'b1;
          entrada_i <= {24'h0, SW[15:8]};
      end else if (b1_press) begin
          // RD_ONE (REG_CONTROL bit2)
          reg_sel_i <= 1'b0; wr_i <= 1'b1;
          entrada_i <= 32'h0000_0004;
      end else if (b2_press) begin
          // ENVIAR ráfaga (REG_CONTROL bit0)
          reg_sel_i <= 1'b0; wr_i <= 1'b1;
          entrada_i <= 32'h0000_0001;
      end else if (b3_press) begin
          // LEER ráfaga (REG_CONTROL bit1)
          reg_sel_i <= 1'b0; wr_i <= 1'b1;
          entrada_i <= 32'h0000_0002;
      end else begin
          // lectura pasiva de DATOS (opcional)
          reg_sel_i  <= 1'b1;
          wr_i       <= 1'b0;
          dato_leido <= salida_o[7:0];
      end
        
      end
      end

endmodule
