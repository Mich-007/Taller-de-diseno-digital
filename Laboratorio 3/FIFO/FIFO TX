`timescale 1ns/1ps
// fifo_tx_uart.sv
// TX: la CPU/BUS escribe bytes; el motor UART hace pop cuando quiere enviar.

module fifo_tx_uart (
    input  logic        clk_100MHz,   // reloj de placa (p.ej. Nexys)
    input  logic        rst,          // reset síncrono activo en 1 (a clk_100MHz)
    // Clock UART interno (16 MHz) y bloqueo del PLL
    output logic        clk_16MHz,    // exportado por si lo ocupas en la UART
    output logic        pll_locked,

    // Interfaz de escritura (lado CPU/BUS)
    input  logic [7:0]  din,          // dato a transmitir
    input  logic        wr_en,        // pulso de escritura (si !full)

    // Interfaz de lectura (lado UART TX)
    input  logic        rd_en,        // pop cuando el TX necesita el siguiente byte
    output logic [7:0]  dout,         // dato al UART TX

    // Estado
    output logic        full,
    output logic        empty,
    output logic [8:0]  data_count    // ocupación 0..512 (DEPTH=512)
);
    // ------------------ Clocking ------------------
    // Reusa el mismo esquema de tu “FIFO GENERAL”: Clocking Wizard -> 16 MHz
    logic srst;

    clk_wiz_0 u_clk (
        .clk_in1 (clk_100MHz),
        .reset   (rst),
        .clk_out1(clk_16MHz),     // 16 MHz
        .locked  (pll_locked)
    );

    // Reset del FIFO solo cuando el PLL ya está bloqueado.
    assign srst = rst | ~pll_locked;

    // ------------------ FIFO Generator (TX) ------------------
    // Configuración de la IP en Vivado:
    // - Interface: Native
    // - Common Clock (synchronous)
    // - Data width: 8
    // - Depth: 512 (BRAM)
    // - First Word Fall-Through: DESACTIVADO (Standard FIFO)
    // - Habilitar puertos: full, empty, data_count, srst
    fifo_tx_core u_fifo_tx (
        .clk        (clk_16MHz),
        .srst       (srst),
        .din        (din),
        .wr_en      (wr_en),
        .rd_en      (rd_en),
        .dout       (dout),
        .full       (full),
        .empty      (empty),
        .data_count (data_count)
    );
endmodule
